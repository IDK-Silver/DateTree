# 4. 預設個人日曆與類型系統

日期: 2025-06-30

## 狀態

已接受

## 背景

系統要求每個 `List` (清單) 物件都必須關聯到一個 `Calendar` (日曆)。這對新註冊的使用者造成了問題，因為他們在註冊後沒有立即擁有日曆，從而無法建立清單。

此外，為了確保基礎的使用者體驗，並防止使用者意外地將自己置於無法建立任何內容的狀態，讓每個使用者始終擁有至少一個日曆是至關重要的。

我們需要一個穩健的機制來達成以下目標：
1.  在使用者註冊時，自動為其提供一個預設日曆。
2.  能夠區分此預設日曆和使用者自行建立的日曆。
3.  防止此預設日曆被刪除。

## 決策

我們決定在 `Calendar` 模型中實作一個 `calendar_type` (日曆類型) 系統。

1.  **引入 `CalendarType` 枚舉 (Enum)**: 在日曆模型中加入一個包含 `PERSONAL` 和 `GENERAL` 兩個值的枚舉。
    *   `PERSONAL`: 代表與使用者帳號關聯的、自動建立且不可刪除的個人日曆。
    *   `GENERAL`: 代表由使用者建立的、可以自由修改或刪除的標準通用日曆。

2.  **註冊時自動建立**: 修改了使用者建立的邏輯 (`crud_user.create`)，在同一個資料庫交易中，為每個新使用者自動產生一個 `PERSONAL` 類型的日曆。該日曆會被預先命名 (例如，「{使用者名稱}的個人日曆」)。

3.  **強制刪除保護**: 更新了 `DELETE /api/v1/calendars/{calendar_id}` 端點，使其在刪除前檢查 `calendar_type`。如果類型為 `PERSONAL`，請求將被拒絕並回傳 `403 Forbidden` 錯誤，從而保護該日曆不被刪除。

## 後果

### 正面影響

*   **保證資料完整性**: 確保每個使用者都至少擁有一個日曆，這保證了新的 `List` 或 `Event` 物件永遠都有一個有效的父容器。
*   **改善使用者體驗**: 新使用者註冊後可以立即開始建立內容，無需先手動建立日曆。
*   **簡化客戶端邏輯**: 前端應用程式無需處理「零日曆」的邊界情況，可以假設至少有一個日曆始終存在。
*   **高擴充性**: 基於 `Enum` 的方法允許未來輕鬆添加新的特殊日曆類型 (例如，`COMPANY_HOLIDAYS` 公司假日, `SHARED_TEAM_CALENDAR` 團隊共享日曆)，而無需進一步的資料庫結構變更。

### 負面影響

*   **輕微增加複雜性**: 與沒有預設日曆系統相比，這在使用者建立和日曆刪除的路徑中引入了一個新欄位和稍微複雜的邏輯。
*   **需要資料庫遷移**: 需要執行一次 Alembic 遷移，以將 `calendar_type` 欄位添加到 `calendars` 資料表中。